y = c(smu(1, 0, 0, 0)[["y"]], smu(0, 0, 0, 1)[["y"]]),
z = c(smu(1, 0, 0, 0)[["z"]], smu(0, 0, 0, 1)[["z"]]), col = f.col,
type = "l", add = T, lwd = 1)
rgl::plot3d(x = c(smu(0, 0, 0, 1)[["x"]], smu(0, 0, 1, 0)[["x"]]),
y = c(smu(0, 0, 0, 1)[["y"]], smu(0, 0, 1, 0)[["y"]]),
z = c(smu(0, 0, 0, 1)[["z"]], smu(0, 0, 1, 0)[["z"]]), col = f.col,
type = "l", add = T, lwd = 1)
rgl::plot3d(x = c(smu(1, 0, 0, 0)[["x"]], smu(0, 0, 1, 0)[["x"]]),
y = c(smu(1, 0, 0, 0)[["y"]], smu(0, 0, 1, 0)[["y"]]),
z = c(smu(1, 0, 0, 0)[["z"]], smu(0, 0, 1, 0)[["z"]]), col = f.col,
type = "l", add = T, lwd = 1)
rgl::plot3d(x = c(smu(0, 1, 0, 0)[["x"]], smu(0, 0, 1, 0)[["x"]]),
y = c(smu(0, 1, 0, 0)[["y"]], smu(0, 0, 1, 0)[["y"]]),
z = c(smu(0, 1, 0, 0)[["z"]], smu(0, 0, 1, 0)[["z"]]), col = f.col,
type = "l", add = T, lwd = 1)
rgl::plot3d(x = c(smu(0, 1, 0, 0)[["x"]], smu(0, 0, 0, 1)[["x"]]),
y = c(smu(0, 1, 0, 0)[["y"]], smu(0, 0, 0, 1)[["y"]]),
z = c(smu(0, 1, 0, 0)[["z"]], smu(0, 0, 0, 1)[["z"]]), col = f.col,
type = "l", add = T, lwd = 1)
rgl::plot3d(x = c(smu(0, 1, 0, 0)[["x"]], smu(1, 0, 0, 0)[["x"]]),
y = c(smu(0, 1, 0, 0)[["y"]], smu(1, 0, 0, 0)[["y"]]),
z = c(smu(0, 1, 0, 0)[["z"]], smu(1, 0, 0, 0)[["z"]]), col = f.col,
type = "l", add = T, lwd = 1)
rgl::text3d(x = smu(1, 0, 0, 0)[["x"]], y = smu(1, 0, 0, 0)[["y"]],
z = smu(1, 0, 0, 0)[["z"]], texts = vnames[[1]], cex = 1, adj = c(0,
0))
rgl::text3d(x = smu(0, 1, 0, 0)[["x"]], y = smu(0, 1, 0, 0)[["y"]],
z = smu(0, 1, 0, 0)[["z"]], texts = vnames[[2]], cex = 1, adj = c(1,
1))
rgl::text3d(x = smu(0, 0, 1, 0)[["x"]], y = smu(0, 0, 1, 0)[["y"]],
z = smu(0, 0, 1, 0)[["z"]], texts = vnames[[3]], cex = 1, adj = c(1,
1))
rgl::text3d(x = smu(0, 0, 0, 1)[["x"]], y = smu(0, 0, 0, 1)[["y"]],
z = smu(0, 0, 0, 1)[["z"]], texts = vnames[[4]], cex = 1, adj = c(1,
1))
if (vectors == TRUE) {
rgl::arrow3d(p0=c(0,0,0),p1=smu(1, 0, 0, 0), width = 1/3, s=1/6)
rgl::arrow3d(p0=c(0,0,0),p1=smu(0, 1, 0, 0), width = 1/3, s=1/6)
rgl::arrow3d(p0=c(0,0,0),p1=smu(0, 0, 1, 0), width = 1/3, s=1/6)
rgl::arrow3d(p0=c(0,0,0),p1=smu(0, 0, 0, 1), width = 1/3, s=1/6)
}
} else {
stop("You need to install rgl to use this function",
call. = FALSE)
}
}
RNLthres <-function (photo=ncol(C)-1,
Rb, I, C, noise=TRUE, v=NA, n=NA, e=NA,
interpolate=TRUE, nm=seq(300,700,1)) {
dependent <- FALSE
nphoto = ncol(C) - 1
photo1<-photo
if (photo=="di") {photo1<-2}
if (photo=="tri") {photo1<-3}
if (photo=="tetra") {photo1<-4}
#warnings
ifelse(photo1 != nphoto, yes = warning("Argument 'C' has a number of sensitivity curves different than argument 'photo'.",
call. = FALSE), no = "")
ifelse(photo1 != length(e) && noise == T,
yes = warning("Argument 'e' has a number of parameters different than 'photo'.",
call. = FALSE), no = "")
ifelse(photo1 != length(n) && noise == F,
yes = warning("Argument 'n' has a number of parameters different than 'photo'.",
call. = FALSE), no = "")
ifelse(any(ncol(I) > 2), yes = warning("'I' argument with more than two columns. Only the first two will be used.",
call. = FALSE), no = "")
ifelse(any(ncol(Rb) > 2), yes = warning("'Rb' argument with more than two columns. Only the first two will be used.",
call. = FALSE), no = "")
#Rb photon catch
SRb<-vector(length=photo1)
for (i in 1:photo1) {
SRb[[i]] <- Q(I = I, R = Rb, C = C[, c(1, i+1)], interpolate = interpolate, nm = nm)
}
#k parameter (Vorobyev and Osorio 1998 eq. 2)
k<-1/SRb
#noise
noise_values<-vector(length=photo1)
if (dependent == FALSE) {
noise_values<-noise_e(noise = noise, e = e, v = v, n = n)
}
#photoreceptors
Cnew<-C
if (interpolate == TRUE) {
Cnew<-data.frame(nm=nm)
for (i in 1:photo1) {
temp<-approx(x = C[, 1], y = C[,i+1], xout = nm, method = "linear")$y
Cnew<-cbind(Cnew, temp)
}
}
#kR Vorobyev and Osorio eq. 6
kR<-matrix(ncol=photo1,nrow=nrow(Cnew))
for (i in 1:length(k)) {
kR[,i]<-k[[i]]*Cnew[,i+1]
}
#threshold
if (photo1>2) {
T1<-combn(x=noise_values, m=(photo1-1))
for (i in 2:nrow(T1)) {
T1[1,]<-T1[1,]*T1[i,]
}
T1<-sum(T1[1,]^2)
}
if(photo1==2) {T1<-sum(noise_values^2)}
cols<-1:photo1
cols.comb<-combn(x=cols, m=2)
T2.kR<-matrix(nrow=nrow(kR), ncol=ncol(cols.comb))
for (i in 1:ncol(cols.comb)) {
T2.kR[,i]<-kR[,cols.comb[1,i]]-kR[,cols.comb[2,i]]
}
T2.kR<-T2.kR^2
if(photo1==2) {T2.e<-1}
if(photo1==3) {T2.e<-noise_values[photo1:1]^2}
if(photo1>=4) {
T2.e<-combn(x=noise_values, m=(photo1-2))
for (i in 2:nrow(T2.e)) {
T2.e[1,]<-T2.e[1,]*T2.e[i,]
}
T2.e<-T2.e[1,]^2
T2.e<-T2.e[length(T2.e):1]
}
T2<-T2.kR
for (i in 1:ncol(T2)) {
T2[,i]<-T2.kR[,i]*T2.e[[i]]
}
if(ncol(T2)>1) {
T2<-rowSums(T2)
}
Thres <- sqrt(T1/T2)
S<-log(1/Thres)
#results
r<-data.frame(nm,Thres,S)
names(r)<-c("nm","T","S")
class(r)<-c("colourvision", "data.frame")
attr(r, "model_name") <- "RNL Threshold"
attr(r, "n_photor_types") <- photo1
attr(r, "Rb") <- Rb
attr(r, "I") <- I
attr(r, "C") <- C
attr(r, "noise calculated") <- noise
attr(r, "v") <- v
attr(r, "n") <- n
attr(r, "Interpolate") <- interpolate
attr(r, "nm") <- nm
return (r)
}
plot.colourvision <- function (x, ...) {
photo1<-attributes(x)$n_photor_types
model<-attributes(x)$model_name
if(photo1==4 && model!="RNL Threshold")
{stop("For a 3D plot use 'plot3d.colourvision'.")}
if(photo1>4  && model!="RNL Threshold")
{stop("Plotting is not available for > 3-dimentions.")}
if (model=="Colour hexagon model") {
if (photo1==3) {
CTTKhexagon(x=x[,"X1"], y=x[,"X2"], photo=3, ...)
}
if (photo1==2) {
CTTKhexagon(x=x[,"X1"], y=0, photo=2, ...)
}
}
if (model=="Endler and Mielke model") {
if (photo1==3) {
EMtriangle(x=x[,"X1"],y=x[,"X2"], type=attributes(x)$type, ...)
}
if (photo1==2) {
EMline(x=x[,"X1"], type=attributes(x)$type, ...)
}
}
if (model=="Receptor noise limited model") {
RNLplot(model=x, photo=photo1, ...)
}
if (model=="Generic model") {
GENplot(model=x, photo=photo1, ...)
}
if (model=="RNL Threshold") {
plot(x$S~x$nm, xlab="Wavelength(nm)", ylab="Ln Sensitivity", type="l", ...)
}
}
RNLplot<-function(model, photo, item="R1",
vectors=TRUE, vnames=TRUE, vsize="auto",
xlab="x", ylab="y", xlim="auto", ylim="auto", asp=1, ...) {
if(item=="R1"){col.names<-c("X1_R1","X2_R1")}
if(item=="R2"){col.names<-c("X1_R2","X2_R2")}
if (attributes(model)$coord!="colourvision" && vectors==TRUE) {
warning("Vector plotting is available only for colour locus coordinates calculted by Gawryszewski (2018) method.")
vectors<-FALSE
vnames<-FALSE
}
GENplot(model=model, photo=photo, col.names=col.names,
vectors=vectors, vnames=vnames, vsize=vsize,
ylab=ylab, xlab=xlab, ylim=ylim, xlim=xlim, asp=asp, ...)
}
GENplot<-function(model, photo, col.names=c("X1","X2"),
vectors=TRUE, vnames=TRUE, vsize="auto",
ylab="y", xlab="x", xlim="auto", ylim="auto", asp=1, ...) {
x<-model
if (photo==2) {
X1<-x[,colnames(x)%in%col.names[[1]]]
lim<-max(abs(c(max(X1, na.rm = TRUE), min(X1, na.rm = TRUE))))
if (ylim[[1]]=="auto") {
ylim<-c(-lim,lim)
}
if (xlim[[1]]=="auto") {
xlim<-c(-lim,lim)
}
plot(x=X1,y=rep(0, length(X1)), ylim=c(-lim,lim),xlim=c(-lim,lim),
ann=FALSE, axes = FALSE, xlab="x",
panel.first=c(
segments(x0=0,x1=lim,y0=0,y1=0),
segments(x0=0,x1=-lim,y0=0,y1=0),
segments(x0=lim,x1=lim,y0=-lim*0.03,y1=lim*0.03),
segments(x0=-lim,x1=-lim,y0=-lim*0.03,y1=lim*0.03),
points(x=0,y=0,pch=4)), ...)
if (vnames == TRUE) {
cs.vsize<-colour_space(n=2, type="length", length=lim)
text(pos=1, x=cs.vsize$vector_matrix[1,1], y=0, labels="E1")
text(pos=1, x=cs.vsize$vector_matrix[1,2], y=0, labels="E2")
}
}
if (photo==3) {
X1<-c(x[,colnames(x)%in%col.names[[1]]])
X2<-c(x[,colnames(x)%in%col.names[[2]]])
lim<-max(abs(c(max(X1, na.rm = TRUE), min(X1, na.rm = TRUE), max(X2, na.rm = TRUE), min(X2, na.rm = TRUE))))
if (ylim[[1]]=="auto") {
ylim<-c(-lim,lim)
}
if (xlim[[1]]=="auto") {
xlim<-c(-lim,lim)
}
if (vsize[[1]]=="auto") {
cs.vsize<-colour_space(n=3, type="length", length=lim[[1]]*0.7)
}
if (vsize[[1]]!="auto") {
cs.vsize<-colour_space(n=3, type="length", length=vsize)
}
plot(x=X1,y=X2,
ylab=ylab, xlab=xlab, xlim=xlim, ylim=ylim, asp=asp,
panel.first ={
if (vectors == TRUE) {
arrows(x0=0,y0=0,x1=cs.vsize$vector_matrix[1,1], y1=cs.vsize$vector_matrix[2,1], length = 0.10)
arrows(x0=0,y0=0,x1=cs.vsize$vector_matrix[1,2], y1=cs.vsize$vector_matrix[2,2], length = 0.10)
arrows(x0=0,y0=0,x1=cs.vsize$vector_matrix[1,3], y1=cs.vsize$vector_matrix[2,3], length = 0.10)
}
},
...)
if (vnames == TRUE) {
text(pos=1, x=cs.vsize$vector_matrix[1,1], y=cs.vsize$vector_matrix[2,1], labels="E1")
text(pos=1, x=cs.vsize$vector_matrix[1,2], y=cs.vsize$vector_matrix[2,2], labels="E2")
text(pos=3, x=cs.vsize$vector_matrix[1,3], y=cs.vsize$vector_matrix[2,3], labels="E3")
}
}
}
RNLplot3d<-function(model, item="R1",
vectors=TRUE, vnames=TRUE, vsize="auto",
xlab="x", ylab="y", zlab="z",
xlim="auto", ylim="auto", zlim="auto", asp=1, ...) {
if(item=="R1"){col.names<-c("X1_R1","X2_R1","X3_R1")}
if(item=="R2"){col.names<-c("X1_R2","X2_R2","X3_R2")}
if (attributes(model)$coord!="colourvision" && vectors==TRUE) {
warning("Vector plotting is available only for colour locus coordinates calculted by Gawryszewski (2018) method.")
vectors<-FALSE
vnames<-FALSE
}
GENplot3d(model=model, col.names=col.names,
vectors=vectors, vnames=vnames, vsize=vsize,
xlab=xlab, ylab=ylab, zlab=zlab,
xlim=xlim, ylim=ylim, zlim=zlim, asp=asp, ...)
}
GENplot3d<-function(model, col.names=c("X1","X2","X3"),
vectors=TRUE, vnames=TRUE, vsize="auto",
xlab="x", ylab="y", zlab="z",
xlim="auto", ylim="auto", zlim="auto", asp=1, ...) {
if (requireNamespace("rgl", quietly = TRUE)) {
x<-model
X1<-x[,col.names[[1]]]
X2<-x[,col.names[[2]]]
X3<-x[,col.names[[3]]]
lim<-max(abs(c(max(X1, na.rm = TRUE), min(X1, na.rm = TRUE),
max(X2, na.rm = TRUE), min(X2, na.rm = TRUE),
max(X3, na.rm = TRUE), min(X3, na.rm = TRUE))))
if (ylim[[1]]=="auto") {
ylim<-c(-lim,lim)
}
if (xlim[[1]]=="auto") {
xlim<-c(-lim,lim)
}
if (zlim[[1]]=="auto") {
zlim<-c(-lim,lim)
}
if (vsize[[1]]=="auto") {
cs.vsize<-colour_space(n=4, type="length", length=lim*0.7)
}
if (vsize[[1]]!="auto") {
cs.vsize<-colour_space(n=4, type="length", length=vsize)
}
rgl::plot3d(x=X1,y=X2,z=X3,
ylab=ylab, xlab=xlab, zlab=zlab, xlim=xlim, ylim=ylim, zlim=zlim, asp=asp, ...)
if (vectors == TRUE) {
rgl::arrow3d(p0=c(0,0,0),p1=cs.vsize$vector_matrix[,1], width = 1/3, s=1/6)
rgl::arrow3d(p0=c(0,0,0),p1=cs.vsize$vector_matrix[,2], width = 1/3, s=1/6)
rgl::arrow3d(p0=c(0,0,0),p1=cs.vsize$vector_matrix[,3], width = 1/3, s=1/6)
rgl::arrow3d(p0=c(0,0,0),p1=cs.vsize$vector_matrix[,4], width = 1/3, s=1/6)
}
if (vnames == TRUE) {
cs<-colour_space(n=4, type="length", length=1)
rgl::text3d(x = cs.vsize$vector_matrix[1,1],
y = cs.vsize$vector_matrix[2,1],
z = cs.vsize$vector_matrix[3,1],
texts = "E1",
cex = 0.75, adj = c(1, 1))
rgl::text3d(x = cs.vsize$vector_matrix[1,2],
y = cs.vsize$vector_matrix[2,2],
z = cs.vsize$vector_matrix[3,2],
texts = "E2",
cex = 0.75, adj = c(1, 1))
rgl::text3d(x = cs.vsize$vector_matrix[1,3],
y = cs.vsize$vector_matrix[2,3],
z = cs.vsize$vector_matrix[3,3],
texts = "E3",
cex = 0.75, adj = c(1, 1))
rgl::text3d(x = cs.vsize$vector_matrix[1,4],
y = cs.vsize$vector_matrix[2,4],
z = cs.vsize$vector_matrix[3,4],
texts = "E4",
cex = 0.75, adj = c(1, 1))
}
} else {
stop("You need to install rgl to use this function",
call. = FALSE)
}
}
plot3d.colourvision <- function (x, ...) {
photo1<-attributes(x)$n_photor_types
if(photo1<=3) {stop("For a 2D plot use 'plot'.")}
if(photo1>4) {stop("Plotting is not available for > 3-dimentions.")}
model<-attributes(x)$model_name
if(model=="RNL Threshold") {stop("For a colour threshold use 'plot'.")}
if (model=="Colour hexagon model") {
if (photo1==4) {
CTTKhexagon3D(x=x[,"X1"],y=x[,"X2"], z=x[,"X3"], ...)
}
}
if (model=="Endler and Mielke model") {
if (photo1==4) {
EMtetrahedron(x=x[,"X1"], y=x[,"X2"], z=x[,"X3"], ...)
}
}
if (model=="Receptor noise limited model") {
if (photo1==4) {
RNLplot3d(model=x, ...)
}
}
if (model=="Generic model") {
if (photo1==4) {
GENplot3d(model=x, ...)
}
}
}
deltaS<-function(model) {
n<-attr(model, "n_photor_types")
col.names<-paste(rep("X",n-1),1:(n-1),sep="")
if (attr(model, "model_name")=="Receptor noise limited model") {
col.names<-paste(rep("X",n-1),1:(n-1),rep("_R1",n-1), sep="")
}
X<-model[,colnames(model)%in%col.names]
X<-data.frame(X)
r<-matrix(ncol=nrow(model),nrow=nrow(model))
colnames(r)<-rownames(model)
rownames(r)<-rownames(model)
for (i in 1:nrow(r)) {
sumX<-rep(0, nrow(X))
for (k in 1:ncol(X)) {
temp<-(X[i,k]-X[,k])^2
sumX<-(temp+sumX)
}
r[,i]  <- sqrt(sumX)
}
return(r)
}
radarplot <- function(model, item=c("Qr", "E"), item.labels=FALSE, item.lwd=1,
border=NULL, radar.lwd=1, radar.col="grey",
length="auto", xlim="auto", ylim="auto",
xlab="", ylab="", asp=1, add = FALSE, ...) {
photo1<-attr(model, "n_photor_types")
model.type<-attr(model, "model_name")
ifelse (test=model.type=="RNL Threshold", yes=stop("radarplot isn't available for RNLthres() model", call. = FALSE), no="")
ifelse (test=photo1==2, yes=stop("radarplot isn't available for dichromatic models", call. = FALSE), no="")
if (item == "Qr") {
col.names<-paste(rep("Qr",photo1),1:photo1,sep="")
if (attr(model, "model_name")=="Receptor noise limited model") {
col.names<-paste(rep("Qr",photo1),1:(photo1),rep("_R1",photo1), sep="")
}
}
if (item == "E") {
col.names<-paste(rep("E",photo1),1:photo1,sep="")
if (attr(model, "model_name")=="Receptor noise limited model") {
col.names<-paste(rep("E",photo1),1:(photo1),rep("_R1",photo1), sep="")
}
}
ifelse (test=any(model[,colnames(model)%in%col.names]<0),
yes=warning("Model has negative photoreceptor values. These values won't be properly represented into a radarplot", call.=FALSE), no="")
colour.matrix<-matrix(ncol=length(col.names),nrow=2)
colour.matrix[1,1]<-0
colour.matrix[2,1]<-1
tetha<-(2*pi)/length(col.names)
for (i in 2:length(col.names)) {
colour.matrix[1,i]<-colour.matrix[1,i-1]*cos(tetha)-colour.matrix[2,i-1]*sin(tetha)
colour.matrix[2,i]<-colour.matrix[1,i-1]*sin(tetha)+colour.matrix[2,i-1]*cos(tetha)
}
max<-length
if(length[[1]]=="auto") {
length.max<-round(max(abs(model[,names(model)%in%col.names]))*1.1,0)
if (model.type == "Colour hexagon model" && item == "E") {
length.max <- 1.0
}
if (model.type == "model_name" && item == "E") {
if (attr(model, "type")=="length") {
length.max <- 0.75
}
if (attr(model, "type")=="edge") {
length.max<-colour_space(n=photo1, type="edge", edge=sqrt(3/2))$vector_matrix
length.max<-sqrt(sum(length.max[,1]^2))
}
}
}
if (xlim[[1]]=="auto") {
max<-round(max(abs(model[,names(model)%in%col.names]))*1.2,0)
xlim<-c(-max,max)
if (model.type == "Colour hexagon model" && item == "E") {
xlim<-c(-1.2,1.2)
}
if (model.type == "model_name" && item == "E") {
if (attr(model, "type")=="length") {
xlim<-c(-1,1)
}
if (attr(model, "type")=="edge") {
length.max<-colour_space(n=photo1, type="edge", edge=sqrt(3/2))$vector_matrix
length.max<-sqrt(sum(length.max[,1]^2))
xlim<-c(-1.2*length.max,length.max*1.2)
}
}
}
if (ylim[[1]]=="auto") {
max<-round(max(abs(model[,names(model)%in%col.names]))*1.2,0)
ylim<-c(-max,max)
if (model.type == "Colour hexagon model" && item == "E") {
ylim<-c(-1.2,1.2)
}
if (model.type == "model_name" && item == "E") {
if (attr(model, "type")=="length") {
ylim<-c(-1,1)
}
if (attr(model, "type")=="edge") {
length.max<-colour_space(n=photo1, type="edge", edge=sqrt(3/2))$vector_matrix
length.max<-sqrt(sum(length.max[,1]^2))
ylim<-c(-1.2*length.max,length.max*1.2)
}
}
}
if (add==FALSE) {
plot(x=0,y=0, ylim=ylim, xlim=xlim, asp=asp, type="n",
xlab=xlab, ylab=ylab, ...)
for (i in 1:ncol(colour.matrix)) {
segments(x0=0,y0=0,x1=colour.matrix[1,i]*length.max,y1=colour.matrix[2,i]*length.max,
col=radar.col, lwd=radar.lwd)
if (item.labels==TRUE) {text(x=colour.matrix[1,i]*length.max,y=colour.matrix[2,i]*length.max, labels=col.names[[i]], cex=0.7)}
}
}
for (i in 1:nrow(model)) {
values<-model[i,names(model)%in%col.names]
matrix.values<-colour.matrix
for (k in 1:ncol(matrix.values)) {
matrix.values[,k]<-colour.matrix[,k]*values[[k]]
}
polygon(x=matrix.values[1,], y=matrix.values[2,], border=border[[i]], lwd=item.lwd)
}
}
#1
## Photoreceptor sensitivity spectra
##with lambda max at 350nm, 450nm and 550nm:
C<-photor(lambda.max=c(350,450,550))
##Grey background
##with 7 percent reflectance from 300 to 700nm:
Rb <- data.frame(300:700, rep(7, length(300:700)))
## Read CIE D65 standard illuminant:
data("D65")
##Reflectance data of R1 and R2
R1.1<-logistic(x=seq(300,700,1), x0=500, L=50, k=0.04)
R1.2<-logistic(x=seq(300,700,1), x0=400, L=50, k=0.04)
w<-R1.1[,1]
R1.1<-R1.1[,2]+10
R1.2<-R1.2[,2]+10
R1<-data.frame(w=w, R1.1=R1.1, R1.2=R1.2)
R2<-logistic(x=seq(300,700,1), x0=550, L=50, k=0.04)
R2[,2]<-R2[,2]+10
## Run model
model<-RNLmodel(photo=3, model="log",
R1=R1, R2=R2, Rb=Rb, I=D65, C=C,
noise=TRUE, e = c(0.13, 0.06, 0.12))
#plot
plot(model)
model
#plot
plot(model)
photo1=3
noise_values<-vector(length=photo1)
noise=TRUE
e = c(0.13, 0.06, 0.12)
for (i in 1:photo1) {
noise_values[[i]]<-noise_e(noise = noise, e = e, v = v, n = n)[[i]]
}
noise_values
